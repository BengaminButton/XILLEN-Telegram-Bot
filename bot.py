import asyncio
import json
import logging
import sqlite3
import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from telegram.constants import ParseMode

class SecurityLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class SecurityEvent:
    timestamp: datetime.datetime
    user_id: int
    user_name: str
    event_type: str
    description: str
    level: SecurityLevel
    chat_id: Optional[int] = None
    message_id: Optional[int] = None

class XillenSecurityBot:
    def __init__(self):
        self.config = self.load_config()
        self.security_events: List[SecurityEvent] = []
        self.suspicious_users: Dict[int, Dict] = {}
        self.db = Database()
        self.logger = self.setup_logging()
        
        self.application = Application.builder().token(self.config["token"]).build()
        self.setup_handlers()
        
    def load_config(self) -> dict:
        try:
            with open('config.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            config = {
                "token": "YOUR_BOT_TOKEN_HERE",
                "owner_id": 123456789,
                "log_chat_id": None,
                "security_level": "medium",
                "auto_moderation": True,
                "suspicious_threshold": 3,
                "welcome_message": True,
                "blocked_words": ["hack", "cheat", "exploit", "crack", "bypass", "ddos", "bot", "script", "auto", "macro"],
                "spam_threshold": 5,
                "spam_timeout": 10
            }
            with open('config.json', 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
            return config
    
    def setup_logging(self) -> logging.Logger:
        logger = logging.getLogger('XillenSecurityBot')
        logger.setLevel(logging.INFO)
        
        handler = logging.FileHandler('xillen_telegram_security.log', encoding='utf-8')
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
    
    def setup_handlers(self):
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("security", self.security_command))
        self.application.add_handler(CommandHandler("scan", self.scan_command))
        self.application.add_handler(CommandHandler("warn", self.warn_command))
        self.application.add_handler(CommandHandler("ban", self.ban_command))
        self.application.add_handler(CommandHandler("unban", self.unban_command))
        self.application.add_handler(CommandHandler("logs", self.logs_command))
        self.application.add_handler(CommandHandler("stats", self.stats_command))
        self.application.add_handler(CommandHandler("reload", self.reload_command))
        
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        self.application.add_handler(MessageHandler(filters.ALL, self.handle_all_messages))
        
        self.application.add_handler(CallbackQueryHandler(self.handle_callback))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        chat = update.effective_chat
        
        if chat.type == "private":
            await self.send_private_welcome(update, context)
        else:
            await self.send_group_welcome(update, context)
        
        await self.log_security_event(
            SecurityEvent(
                timestamp=datetime.datetime.now(),
                user_id=user.id,
                user_name=user.first_name,
                event_type="START_COMMAND",
                description=f"User started bot in {chat.type}",
                level=SecurityLevel.LOW,
                chat_id=chat.id
            )
        )
    
    async def send_private_welcome(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        welcome_text = (
            "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
            "‚ïë                    XILLEN Security Bot                      ‚ïë\n"
            "‚ïë                        v2.0 by @Bengamin_Button            ‚ïë\n"
            "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
            "üõ°Ô∏è –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ XILLEN!\n\n"
            "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
            "‚Ä¢ /help - –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É\n"
            "‚Ä¢ /security - —Å—Ç–∞—Ç—É—Å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n"
            "‚Ä¢ /scan @user - –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n"
            "‚Ä¢ /logs - –ø–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥–∏\n"
            "‚Ä¢ /stats - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n"
            "–ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —á–∞—Ç–∞ –∏ —É–≤–µ–¥–æ–º–ª—è–µ—Ç –æ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏."
        )
        
        await update.message.reply_text(welcome_text, parse_mode=ParseMode.HTML)
    
    async def send_group_welcome(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        welcome_text = (
            "üõ°Ô∏è XILLEN Security Bot –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!\n\n"
            "–ë–æ—Ç –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —á–∞—Ç–∞.\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /security –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞."
        )
        
        await update.message.reply_text(welcome_text)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        help_text = (
            "üìö <b>–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º XILLEN Security Bot</b>\n\n"
            "<b>–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n"
            "‚Ä¢ /start - –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞\n"
            "‚Ä¢ /help - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n"
            "‚Ä¢ /security - —Å—Ç–∞—Ç—É—Å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n\n"
            "<b>–ú–æ–¥–µ—Ä–∞—Ü–∏—è:</b>\n"
            "‚Ä¢ /scan @user - –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n"
            "‚Ä¢ /warn @user [–ø—Ä–∏—á–∏–Ω–∞] - –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ\n"
            "‚Ä¢ /ban @user [–ø—Ä–∏—á–∏–Ω–∞] - –∑–∞–±–∞–Ω–∏—Ç—å\n"
            "‚Ä¢ /unban @user - —Ä–∞–∑–±–∞–Ω–∏—Ç—å\n\n"
            "<b>–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥:</b>\n"
            "‚Ä¢ /logs [—Ç–∏–ø] [–ª–∏–º–∏—Ç] - –ª–æ–≥–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n"
            "‚Ä¢ /stats - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n"
            "<b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ:</b>\n"
            "‚Ä¢ /reload - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é\n\n"
            "<b>–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n"
            "‚Ä¢ –î–µ—Ç–µ–∫—Ü–∏—è –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n"
            "‚Ä¢ –ê–Ω—Ç–∏-—Å–ø–∞–º –∑–∞—â–∏—Ç–∞\n"
            "‚Ä¢ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
            "‚Ä¢ –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Å–æ–±—ã—Ç–∏–π"
        )
        
        await update.message.reply_text(help_text, parse_mode=ParseMode.HTML)
    
    async def security_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_permissions(update, context):
            return
        
        chat = update.effective_chat
        total_events = len(self.security_events)
        suspicious_users = len(self.suspicious_users)
        
        security_text = (
            f"üõ°Ô∏è <b>–°—Ç–∞—Ç—É—Å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —á–∞—Ç–∞</b>\n\n"
            f"üìä <b>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
            f"‚Ä¢ –í—Å–µ–≥–æ —Å–æ–±—ã—Ç–∏–π: {total_events}\n"
            f"‚Ä¢ –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {suspicious_users}\n"
            f"‚Ä¢ –£—Ä–æ–≤–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: {self.config.get('security_level', 'medium')}\n\n"
            f"‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏:</b>\n"
            f"‚Ä¢ –ê–≤—Ç–æ–º–æ–¥–µ—Ä–∞—Ü–∏—è: {'‚úÖ –í–∫–ª—é—á–µ–Ω–∞' if self.config.get('auto_moderation', True) else '‚ùå –í—ã–∫–ª—é—á–µ–Ω–∞'}\n"
            f"‚Ä¢ –ü–æ—Ä–æ–≥ –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π: {self.config.get('suspicious_threshold', 3)}\n"
            f"‚Ä¢ –ê–Ω—Ç–∏-—Å–ø–∞–º: {self.config.get('spam_threshold', 5)} —Å–æ–æ–±—â–µ–Ω–∏–π –∑–∞ {self.config.get('spam_timeout', 10)} —Å–µ–∫\n\n"
            f"üîç <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è:</b>\n"
        )
        
        recent_events = self.security_events[-5:] if self.security_events else []
        if recent_events:
            for event in recent_events:
                security_text += f"‚Ä¢ {event.event_type}: {event.description[:50]}...\n"
        else:
            security_text += "‚Ä¢ –°–æ–±—ã—Ç–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ\n"
        
        await update.message.reply_text(security_text, parse_mode=ParseMode.HTML)
    
    async def scan_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_permissions(update, context):
            return
        
        if not context.args:
            await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: /scan @username")
            return
        
        username = context.args[0].replace("@", "")
        user_data = self.suspicious_users.get(username, {})
        total_points = user_data.get("total_points", 0)
        
        scan_text = (
            f"üîç <b>–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è</b>\n\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> @{username}\n"
            f"‚ö†Ô∏è <b>–û—á–∫–∏ –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π:</b> {total_points}\n"
        )
        
        if total_points == 0:
            scan_text += "‚úÖ <b>–°—Ç–∞—Ç—É—Å:</b> –ë–µ–∑–æ–ø–∞—Å–µ–Ω"
        elif total_points < 3:
            scan_text += "‚ö†Ô∏è <b>–°—Ç–∞—Ç—É—Å:</b> –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª–µ–Ω"
        else:
            scan_text += "üö® <b>–°—Ç–∞—Ç—É—Å:</b> –û–ø–∞—Å–µ–Ω"
        
        if user_data.get("reasons"):
            reasons = [r["reason"] for r in user_data["reasons"][-3:]]
            scan_text += f"\n\nüìù <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø—Ä–∏—á–∏–Ω—ã:</b>\n‚Ä¢ " + "\n‚Ä¢ ".join(reasons)
        
        await update.message.reply_text(scan_text, parse_mode=ParseMode.HTML)
    
    async def warn_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_permissions(update, context):
            return
        
        if len(context.args) < 1:
            await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: /warn @username [–ø—Ä–∏—á–∏–Ω–∞]")
            return
        
        username = context.args[0].replace("@", "")
        reason = " ".join(context.args[1:]) if len(context.args) > 1 else "–ü—Ä–∏—á–∏–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞"
        
        await self.add_suspicion(username, "manual_warning", 2)
        
        warn_text = (
            f"‚ö†Ô∏è <b>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –≤—ã–¥–∞–Ω–æ</b>\n\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> @{username}\n"
            f"üëÆ <b>–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä:</b> {update.effective_user.first_name}\n"
            f"üìù <b>–ü—Ä–∏—á–∏–Ω–∞:</b> {reason}\n\n"
            f"‚ö†Ô∏è –û—á–∫–∏ –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π —É–≤–µ–ª–∏—á–µ–Ω—ã –Ω–∞ 2"
        )
        
        await update.message.reply_text(warn_text, parse_mode=ParseMode.HTML)
    
    async def ban_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_admin_permissions(update, context):
            return
        
        if len(context.args) < 1:
            await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: /ban @username [–ø—Ä–∏—á–∏–Ω–∞]")
            return
        
        username = context.args[0].replace("@", "")
        reason = " ".join(context.args[1:]) if len(context.args) > 1 else "–ü—Ä–∏—á–∏–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞"
        
        await self.add_suspicion(username, "manual_ban", 5)
        
        ban_text = (
            f"üö´ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> @{username}\n"
            f"üëÆ <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä:</b> {update.effective_user.first_name}\n"
            f"üìù <b>–ü—Ä–∏—á–∏–Ω–∞:</b> {reason}\n\n"
            f"‚ö†Ô∏è –û—á–∫–∏ –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π —É–≤–µ–ª–∏—á–µ–Ω—ã –Ω–∞ 5"
        )
        
        await update.message.reply_text(ban_text, parse_mode=ParseMode.HTML)
    
    async def unban_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_admin_permissions(update, context):
            return
        
        if not context.args:
            await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: /unban @username")
            return
        
        username = context.args[0].replace("@", "")
        
        if username in self.suspicious_users:
            del self.suspicious_users[username]
            await update.message.reply_text(f"‚úÖ –ü–æ–¥–æ–∑—Ä–µ–Ω–∏—è –¥–ª—è @{username} –æ—á–∏—â–µ–Ω—ã")
        else:
            await update.message.reply_text(f"‚ÑπÔ∏è –£ @{username} –Ω–µ—Ç –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π")
    
    async def logs_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_permissions(update, context):
            return
        
        event_type = context.args[0] if context.args else "all"
        limit = int(context.args[1]) if len(context.args) > 1 else 10
        
        if limit > 25:
            limit = 25
        
        events = self.security_events
        
        if event_type != "all":
            events = [e for e in events if e.event_type == event_type.upper()]
        
        if not events:
            await update.message.reply_text("üìù –õ–æ–≥–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            return
        
        logs_text = f"üìã <b>–õ–æ–≥–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</b> ({len(events)} —Å–æ–±—ã—Ç–∏–π)\n\n"
        
        recent_events = events[-limit:]
        for event in recent_events:
            logs_text += (
                f"<b>[{event.event_type}] {event.user_name}</b>\n"
                f"{event.description}\n"
                f"‚è∞ {event.timestamp.strftime('%H:%M:%S')}\n\n"
            )
        
        await update.message.reply_text(logs_text, parse_mode=ParseMode.HTML)
    
    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_permissions(update, context):
            return
        
        total_events = len(self.security_events)
        event_types = {}
        
        for event in self.security_events:
            event_types[event.event_type] = event_types.get(event.event_type, 0) + 1
        
        stats_text = (
            f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</b>\n\n"
            f"üìà <b>–û–±—â–∏–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏:</b>\n"
            f"‚Ä¢ –í—Å–µ–≥–æ —Å–æ–±—ã—Ç–∏–π: {total_events}\n"
            f"‚Ä¢ –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(self.suspicious_users)}\n\n"
            f"üìã <b>–¢–∏–ø—ã —Å–æ–±—ã—Ç–∏–π:</b>\n"
        )
        
        for event_type, count in sorted(event_types.items(), key=lambda x: x[1], reverse=True)[:5]:
            stats_text += f"‚Ä¢ {event_type}: {count}\n"
        
        await update.message.reply_text(stats_text, parse_mode=ParseMode.HTML)
    
    async def reload_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not await self.check_admin_permissions(update, context):
            return
        
        self.config = self.load_config()
        await update.message.reply_text("‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω–∞")
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        message = update.message
        user = message.from_user
        chat = message.chat
        
        if chat.type == "private":
            return
        
        content = message.text.lower()
        user_id = user.id
        
        await self.process_message(message)
        await self.log_message_event(message)
    
    async def handle_all_messages(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        message = update.message
        user = message.from_user
        chat = message.chat
        
        if chat.type == "private":
            return
        
        if user.is_bot:
            return
        
        await self.check_new_user(user, chat)
    
    async def process_message(self, message):
        content = message.text.lower()
        user_id = message.from_user.id
        username = message.from_user.username or str(user_id)
        
        if await self.is_suspicious_content(content):
            await self.handle_suspicious_message(message)
            await self.add_suspicion(username, "suspicious_content", 1)
        
        if await self.is_spam(message):
            await self.handle_spam(message)
            await self.add_suspicion(username, "spam", 2)
    
    async def is_suspicious_content(self, content: str) -> bool:
        blocked_words = self.config.get("blocked_words", [])
        return any(word in content for word in blocked_words)
    
    async def is_spam(self, message) -> bool:
        user_id = message.from_user.id
        username = message.from_user.username or str(user_id)
        
        if username not in self.suspicious_users:
            return False
        
        user_data = self.suspicious_users[username]
        recent_messages = user_data.get("recent_messages", [])
        
        now = datetime.datetime.now()
        recent_messages = [msg for msg in recent_messages if (now - msg).seconds < self.config.get("spam_timeout", 10)]
        
        if len(recent_messages) >= self.config.get("spam_threshold", 5):
            return True
        
        recent_messages.append(now)
        user_data["recent_messages"] = recent_messages
        return False
    
    async def handle_suspicious_message(self, message):
        embed_text = (
            f"‚ö†Ô∏è <b>–ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ</b>\n\n"
            f"üë§ <b>–ê–≤—Ç–æ—Ä:</b> {message.from_user.first_name}\n"
            f"üí¨ <b>–ß–∞—Ç:</b> {message.chat.title}\n"
            f"üìù <b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b> {message.text[:100]}{'...' if len(message.text) > 100 else ''}\n\n"
            f"‚è∞ –í—Ä–µ–º—è: {datetime.datetime.now().strftime('%H:%M:%S')}"
        )
        
        await self.send_security_alert(embed_text)
    
    async def handle_spam(self, message):
        embed_text = (
            f"üö´ <b>–°–ø–∞–º –æ–±–Ω–∞—Ä—É–∂–µ–Ω</b>\n\n"
            f"üë§ <b>–ê–≤—Ç–æ—Ä:</b> {message.from_user.first_name}\n"
            f"üí¨ <b>–ß–∞—Ç:</b> {message.chat.title}\n\n"
            f"‚è∞ –í—Ä–µ–º—è: {datetime.datetime.now().strftime('%H:%M:%S')}"
        )
        
        await self.send_security_alert(embed_text)
        
        if self.config.get("auto_moderation", True):
            await self.add_suspicion(
                message.from_user.username or str(message.from_user.id),
                "spam_detection",
                2
            )
    
    async def add_suspicion(self, username: str, reason: str, points: int):
        if username not in self.suspicious_users:
            self.suspicious_users[username] = {
                "total_points": 0,
                "reasons": [],
                "recent_messages": []
            }
        
        user_data = self.suspicious_users[username]
        user_data["total_points"] += points
        user_data["reasons"].append({
            "reason": reason,
            "points": points,
            "timestamp": datetime.datetime.now()
        })
        
        if user_data["total_points"] >= self.config.get("suspicious_threshold", 3):
            await self.handle_high_suspicion(username, user_data)
    
    async def handle_high_suspicion(self, username: str, user_data: dict):
        embed_text = (
            f"üö® <b>–í—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π</b>\n\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> @{username}\n"
            f"‚ö†Ô∏è <b>–û—á–∫–∏ –ø–æ–¥–æ–∑—Ä–µ–Ω–∏–π:</b> {user_data['total_points']}\n\n"
            f"üìù <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø—Ä–∏—á–∏–Ω—ã:</b>\n"
        )
        
        reasons = [r["reason"] for r in user_data["reasons"][-5:]]
        embed_text += "‚Ä¢ " + "\n‚Ä¢ ".join(reasons)
        
        await self.send_security_alert(embed_text)
    
    async def send_security_alert(self, text: str):
        log_chat_id = self.config.get("log_chat_id")
        if log_chat_id:
            try:
                await self.application.bot.send_message(
                    chat_id=log_chat_id,
                    text=text,
                    parse_mode=ParseMode.HTML
                )
            except Exception as e:
                self.logger.error(f"Failed to send security alert: {e}")
    
    async def check_new_user(self, user, chat):
        if user.username:
            username = user.username
        else:
            username = str(user.id)
        
        account_age = datetime.datetime.now() - user.date
        
        if account_age.days < 7:
            embed_text = (
                f"üÜï <b>–ù–æ–≤—ã–π –∞–∫–∫–∞—É–Ω—Ç</b>\n\n"
                f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {user.first_name}\n"
                f"üí¨ <b>–ß–∞—Ç:</b> {chat.title}\n"
                f"üìÖ <b>–í–æ–∑—Ä–∞—Å—Ç –∞–∫–∫–∞—É–Ω—Ç–∞:</b> {account_age.days} –¥–Ω–µ–π\n\n"
                f"‚è∞ –í—Ä–µ–º—è: {datetime.datetime.now().strftime('%H:%M:%S')}"
            )
            
            await self.send_security_alert(embed_text)
    
    async def log_security_event(self, event: SecurityEvent):
        self.security_events.append(event)
        await self.db.log_event(event)
        
        if len(self.security_events) > 1000:
            self.security_events = self.security_events[-1000:]
    
    async def log_message_event(self, message):
        await self.db.log_message(
            message.message_id,
            message.from_user.id,
            message.from_user.first_name,
            message.chat.id,
            message.text,
            message.date
        )
    
    async def check_permissions(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
        user = update.effective_user
        chat = update.effective_chat
        
        if chat.type == "private":
            return True
        
        member = await chat.get_member(user.id)
        return member.status in ["creator", "administrator"] or member.can_restrict_members
    
    async def check_admin_permissions(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
        user = update.effective_user
        chat = update.effective_chat
        
        if chat.type == "private":
            return user.id == self.config.get("owner_id")
        
        member = await chat.get_member(user.id)
        return member.status in ["creator", "administrator"]
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
    
    async def run(self):
        await self.db.init()
        self.logger.info("Database initialized")
        
        print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        print("‚ïë                    XILLEN Security Bot                      ‚ïë")
        print("‚ïë                        v2.0 by @Bengamin_Button            ‚ïë")
        print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        print("Bot is starting...")
        
        await self.application.initialize()
        await self.application.start()
        await self.application.updater.start_polling()
        
        print("Bot is running! Press Ctrl+C to stop.")
        
        try:
            await self.application.updater.idle()
        except KeyboardInterrupt:
            print("\nBot is stopping...")
        finally:
            await self.application.stop()
            await self.application.shutdown()

class Database:
    def __init__(self):
        self.db_path = "xillen_telegram_security.db"
    
    async def init(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS security_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                user_id INTEGER NOT NULL,
                user_name TEXT NOT NULL,
                event_type TEXT NOT NULL,
                description TEXT NOT NULL,
                level TEXT NOT NULL,
                chat_id INTEGER,
                message_id INTEGER
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                user_name TEXT NOT NULL,
                chat_id INTEGER NOT NULL,
                content TEXT NOT NULL,
                timestamp TEXT NOT NULL
            )
        ''')
        
        conn.commit()
        conn.close()
    
    async def log_event(self, event: SecurityEvent):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO security_events 
            (timestamp, user_id, user_name, event_type, description, level, chat_id, message_id)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            event.timestamp.isoformat(),
            event.user_id,
            event.user_name,
            event.event_type,
            event.description,
            event.level.value,
            event.chat_id,
            event.message_id
        ))
        
        conn.commit()
        conn.close()
    
    async def log_message(self, message_id: int, user_id: int, user_name: str, 
                         chat_id: int, content: str, timestamp: datetime.datetime):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO messages 
            (id, user_id, user_name, chat_id, content, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            message_id,
            user_id,
            user_name,
            chat_id,
            content,
            timestamp.isoformat()
        ))
        
        conn.commit()
        conn.close()

async def main():
    bot = XillenSecurityBot()
    
    try:
        await bot.run()
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞: {e}")

if __name__ == "__main__":
    asyncio.run(main())

